{"version":3,"file":"chartImageService-D0un2IL8.js","sources":["../../src/utils/helpers.ts","../../node_modules/uuid/dist/esm-browser/stringify.js","../../node_modules/uuid/dist/esm-browser/rng.js","../../node_modules/uuid/dist/esm-browser/native.js","../../node_modules/uuid/dist/esm-browser/v4.js","../../src/utils/chartImageUtils.ts","../../src/services/chartImageService.ts"],"sourcesContent":["export const generateId = (): string => {\r\n  return Math.random().toString(36).substring(2, 15) +\r\n         Math.random().toString(36).substring(2, 15);\r\n};\r\n\r\nimport { SupabaseService } from '../services/supabaseService';\r\n\r\n/**\r\n * Safely get a value from IndexedDB with fallback\r\n * @param key - IndexedDB key\r\n * @param fallback - fallback value if key doesn't exist or parsing fails\r\n * @param parser - optional parser function (e.g., parseInt, JSON.parse)\r\n * @returns parsed value or fallback\r\n */\r\nexport const getFromIndexedDB = async <T>(\r\n  key: string,\r\n  fallback: T,\r\n  parser?: (value: any) => T\r\n): Promise<T> => {\r\n  try {\r\n    const stored = await SupabaseService.getMiscData(key);\r\n    if (stored === null || stored === undefined) return fallback;\r\n\r\n    if (parser) {\r\n      return parser(stored);\r\n    }\r\n\r\n    return stored as T;\r\n  } catch (error) {\r\n    return fallback;\r\n  }\r\n};\r\n\r\n/**\r\n * Safely set a value in IndexedDB\r\n * @param key - IndexedDB key\r\n * @param value - value to store\r\n * @param serializer - optional serializer function (e.g., JSON.stringify)\r\n * @returns success boolean\r\n */\r\nexport const setToIndexedDB = async <T>(\r\n  key: string,\r\n  value: T,\r\n  serializer?: (value: T) => any\r\n): Promise<boolean> => {\r\n  try {\r\n    const valueToStore = serializer ? serializer(value) : value;\r\n    return await SupabaseService.saveMiscData(key, valueToStore);\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * LEGACY: Safely get a value from localStorage with fallback\r\n * @deprecated Use getFromIndexedDB instead\r\n */\r\nexport const getFromLocalStorage = <T>(\r\n  key: string,\r\n  fallback: T,\r\n  parser?: (value: string) => T\r\n): T => {\r\n  try {\r\n    const stored = localStorage.getItem(key);\r\n    if (stored === null) return fallback;\r\n\r\n    if (parser) {\r\n      return parser(stored);\r\n    }\r\n\r\n    // Try to parse as JSON first, fallback to string\r\n    try {\r\n      return JSON.parse(stored);\r\n    } catch {\r\n      return stored as unknown as T;\r\n    }\r\n  } catch (error) {\r\n    return fallback;\r\n  }\r\n};\r\n\r\n/**\r\n * LEGACY: Safely set a value in localStorage\r\n * @deprecated Use setToIndexedDB instead\r\n */\r\nexport const setToLocalStorage = <T>(\r\n  key: string,\r\n  value: T,\r\n  serializer?: (value: T) => string\r\n): boolean => {\r\n  try {\r\n    const valueToStore = serializer ? serializer(value) :\r\n                        typeof value === 'string' ? value : JSON.stringify(value);\r\n    localStorage.setItem(key, valueToStore);\r\n    return true;\r\n  } catch (error) {\r\n    return false;\r\n  }\r\n};\r\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n","import { ChartImage } from '../types/trade';\r\nimport { ChartImageBlob } from '../db/database';\r\nimport { DatabaseService } from '../db/database';\r\nimport { generateId } from './helpers';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\n// Configuration constants\r\nexport const CHART_IMAGE_CONFIG = {\r\n  MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB max file size\r\n  INLINE_THRESHOLD: 0, // PURE SUPABASE: No inline storage - all images go to Supabase\r\n\r\n  // Enhanced compression settings for smaller file sizes\r\n  COMPRESSION_QUALITY: 0.7, // JPEG compression quality (reduced for smaller files)\r\n  WEBP_QUALITY: 0.65, // WebP compression quality (more aggressive)\r\n  HIGH_COMPRESSION_QUALITY: 0.6, // For very large files\r\n  ULTRA_COMPRESSION_QUALITY: 0.5, // For extremely large files\r\n\r\n  // Dimension limits for different file sizes\r\n  MAX_DIMENSION: 1920, // Reduced from 2048 for smaller files\r\n  LARGE_FILE_MAX_DIMENSION: 1600, // For files > 1MB\r\n  HUGE_FILE_MAX_DIMENSION: 1280, // For files > 3MB\r\n\r\n  // Compression thresholds\r\n  AGGRESSIVE_COMPRESSION_THRESHOLD: 300 * 1024, // 300KB - use more aggressive compression\r\n  HIGH_COMPRESSION_THRESHOLD: 1 * 1024 * 1024, // 1MB - use high compression\r\n  ULTRA_COMPRESSION_THRESHOLD: 3 * 1024 * 1024, // 3MB - use ultra compression\r\n\r\n  ALLOWED_TYPES: ['image/png', 'image/jpeg', 'image/webp'] as const,\r\n  ALLOWED_EXTENSIONS: ['.png', '.jpg', '.jpeg', '.webp'] as const,\r\n\r\n  // Progressive JPEG for better loading experience\r\n  PROGRESSIVE_JPEG: true,\r\n\r\n  // Target file sizes (we'll try to achieve these)\r\n  TARGET_SIZE_SMALL: 100 * 1024, // 100KB target for small charts\r\n  TARGET_SIZE_MEDIUM: 200 * 1024, // 200KB target for medium charts\r\n  TARGET_SIZE_LARGE: 400 * 1024, // 400KB target for large charts\r\n};\r\n\r\n// Image validation\r\nexport interface ImageValidationResult {\r\n  isValid: boolean;\r\n  error?: string;\r\n  warnings?: string[];\r\n}\r\n\r\nexport function validateImageFile(file: File): ImageValidationResult {\r\n  const result: ImageValidationResult = { isValid: true, warnings: [] };\r\n\r\n  // Check file size\r\n  if (file.size > CHART_IMAGE_CONFIG.MAX_FILE_SIZE) {\r\n    result.isValid = false;\r\n    result.error = `File size (${formatFileSize(file.size)}) exceeds maximum allowed size (${formatFileSize(CHART_IMAGE_CONFIG.MAX_FILE_SIZE)})`;\r\n    return result;\r\n  }\r\n\r\n  // Check file type\r\n  if (!CHART_IMAGE_CONFIG.ALLOWED_TYPES.includes(file.type as any)) {\r\n    result.isValid = false;\r\n    result.error = `File type \"${file.type}\" is not supported. Allowed types: ${CHART_IMAGE_CONFIG.ALLOWED_TYPES.join(', ')}`;\r\n    return result;\r\n  }\r\n\r\n  // Check file extension\r\n  const extension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));\r\n  if (!CHART_IMAGE_CONFIG.ALLOWED_EXTENSIONS.includes(extension as any)) {\r\n    result.isValid = false;\r\n    result.error = `File extension \"${extension}\" is not supported. Allowed extensions: ${CHART_IMAGE_CONFIG.ALLOWED_EXTENSIONS.join(', ')}`;\r\n    return result;\r\n  }\r\n\r\n  // Add warnings for large files\r\n  if (file.size > CHART_IMAGE_CONFIG.INLINE_THRESHOLD) {\r\n    result.warnings?.push(`Large file (${formatFileSize(file.size)}) will be stored separately for better performance`);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n// Enhanced image compression with smart format selection\r\nexport async function compressImage(file: File, maxDimension = CHART_IMAGE_CONFIG.MAX_DIMENSION, customQuality?: number): Promise<{\r\n  compressedFile: File;\r\n  originalSize: number;\r\n  compressedSize: number;\r\n  compressionRatio: number;\r\n  outputFormat: string;\r\n}> {\r\n  return new Promise((resolve, reject) => {\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    const img = new Image();\r\n\r\n    img.onload = () => {\r\n      try {\r\n        // Calculate new dimensions with aggressive resizing for large files\r\n        let { width, height } = img;\r\n\r\n        // Determine max dimension based on file size for more aggressive compression\r\n        let effectiveMaxDimension = maxDimension;\r\n        if (file.size > CHART_IMAGE_CONFIG.ULTRA_COMPRESSION_THRESHOLD) {\r\n          effectiveMaxDimension = Math.min(maxDimension, CHART_IMAGE_CONFIG.HUGE_FILE_MAX_DIMENSION); // 1280px for huge files\r\n        } else if (file.size > CHART_IMAGE_CONFIG.HIGH_COMPRESSION_THRESHOLD) {\r\n          effectiveMaxDimension = Math.min(maxDimension, CHART_IMAGE_CONFIG.LARGE_FILE_MAX_DIMENSION); // 1600px for large files\r\n        }\r\n\r\n        const needsResize = width > effectiveMaxDimension || height > effectiveMaxDimension;\r\n\r\n        if (needsResize) {\r\n          const ratio = Math.min(effectiveMaxDimension / width, effectiveMaxDimension / height);\r\n          width = Math.round(width * ratio);\r\n          height = Math.round(height * ratio);\r\n          console.log(`📐 Resizing image: ${img.width}x${img.height} → ${width}x${height} (${effectiveMaxDimension}px limit for ${formatFileSize(file.size)} file)`);\r\n        }\r\n\r\n        // Set canvas dimensions\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n\r\n        // Enable image smoothing for better quality\r\n        if (ctx) {\r\n          ctx.imageSmoothingEnabled = true;\r\n          ctx.imageSmoothingQuality = 'high';\r\n          ctx.drawImage(img, 0, 0, width, height);\r\n        }\r\n\r\n        // Enhanced smart format and quality selection based on file size\r\n        let outputFormat: string;\r\n        let quality: number;\r\n\r\n        // Determine compression level based on file size\r\n        const isUltraLarge = file.size > CHART_IMAGE_CONFIG.ULTRA_COMPRESSION_THRESHOLD;\r\n        const isLarge = file.size > CHART_IMAGE_CONFIG.HIGH_COMPRESSION_THRESHOLD;\r\n        const isModerate = file.size > CHART_IMAGE_CONFIG.AGGRESSIVE_COMPRESSION_THRESHOLD;\r\n\r\n        // Choose optimal format and quality based on file size and type\r\n        if (file.type === 'image/png' && !hasTransparency(ctx, width, height)) {\r\n          // Convert PNG without transparency to JPEG for much better compression\r\n          outputFormat = 'image/jpeg';\r\n          if (customQuality !== undefined) {\r\n            quality = customQuality;\r\n          } else if (isUltraLarge) {\r\n            quality = CHART_IMAGE_CONFIG.ULTRA_COMPRESSION_QUALITY; // 0.5 for huge files\r\n          } else if (isLarge) {\r\n            quality = CHART_IMAGE_CONFIG.HIGH_COMPRESSION_QUALITY; // 0.6 for large files\r\n          } else if (isModerate) {\r\n            quality = CHART_IMAGE_CONFIG.COMPRESSION_QUALITY; // 0.7 for moderate files\r\n          } else {\r\n            quality = 0.8; // Higher quality for small files\r\n          }\r\n        } else if (file.type === 'image/png') {\r\n          // Keep PNG for transparency but try WebP if supported\r\n          if (supportsWebP()) {\r\n            outputFormat = 'image/webp';\r\n            quality = isUltraLarge ? 0.4 : isLarge ? 0.5 : CHART_IMAGE_CONFIG.WEBP_QUALITY;\r\n          } else {\r\n            outputFormat = 'image/png';\r\n            quality = 1; // PNG doesn't use quality parameter\r\n          }\r\n        } else if (supportsWebP()) {\r\n          // Prefer WebP for all large files due to superior compression\r\n          outputFormat = 'image/webp';\r\n          if (customQuality !== undefined) {\r\n            quality = customQuality;\r\n          } else if (isUltraLarge) {\r\n            quality = 0.4; // Very aggressive for huge files\r\n          } else if (isLarge) {\r\n            quality = 0.5; // Aggressive for large files\r\n          } else {\r\n            quality = CHART_IMAGE_CONFIG.WEBP_QUALITY; // 0.65 for normal files\r\n          }\r\n        } else {\r\n          // Default to JPEG with aggressive compression\r\n          outputFormat = 'image/jpeg';\r\n          if (customQuality !== undefined) {\r\n            quality = customQuality;\r\n          } else if (isUltraLarge) {\r\n            quality = CHART_IMAGE_CONFIG.ULTRA_COMPRESSION_QUALITY; // 0.5\r\n          } else if (isLarge) {\r\n            quality = CHART_IMAGE_CONFIG.HIGH_COMPRESSION_QUALITY; // 0.6\r\n          } else if (isModerate) {\r\n            quality = CHART_IMAGE_CONFIG.COMPRESSION_QUALITY; // 0.7\r\n          } else {\r\n            quality = 0.8; // Higher quality for small files\r\n          }\r\n        }\r\n\r\n        // Multi-pass compression to achieve target file sizes\r\n        const tryCompress = (currentQuality: number, attempt: number = 1): void => {\r\n          canvas.toBlob((blob) => {\r\n            if (!blob) {\r\n              reject(new Error('Failed to compress image'));\r\n              return;\r\n            }\r\n\r\n            const compressedFile = new File([blob], file.name, {\r\n              type: outputFormat,\r\n              lastModified: Date.now(),\r\n            });\r\n\r\n            // Determine target size based on original file size\r\n            let targetSize: number;\r\n            if (file.size > CHART_IMAGE_CONFIG.ULTRA_COMPRESSION_THRESHOLD) {\r\n              targetSize = CHART_IMAGE_CONFIG.TARGET_SIZE_LARGE; // 400KB for huge files\r\n            } else if (file.size > CHART_IMAGE_CONFIG.HIGH_COMPRESSION_THRESHOLD) {\r\n              targetSize = CHART_IMAGE_CONFIG.TARGET_SIZE_MEDIUM; // 200KB for large files\r\n            } else {\r\n              targetSize = CHART_IMAGE_CONFIG.TARGET_SIZE_SMALL; // 100KB for normal files\r\n            }\r\n\r\n            // If file is still too large and we can compress more, try again\r\n            if (compressedFile.size > targetSize && currentQuality > 0.3 && attempt < 4 && outputFormat !== 'image/png') {\r\n              const newQuality = Math.max(0.3, currentQuality - 0.15); // Reduce quality by 15%\r\n              console.log(`🔄 File still ${formatFileSize(compressedFile.size)} (target: ${formatFileSize(targetSize)}), trying quality ${newQuality.toFixed(2)} (attempt ${attempt + 1})`);\r\n              tryCompress(newQuality, attempt + 1);\r\n              return;\r\n            }\r\n\r\n            // Success - return the compressed file\r\n            const compressionRatio = file.size / compressedFile.size;\r\n            console.log(`✅ Compression complete: ${formatFileSize(file.size)} → ${formatFileSize(compressedFile.size)} (${compressionRatio.toFixed(2)}x) [${outputFormat}] quality: ${currentQuality.toFixed(2)}`);\r\n\r\n            resolve({\r\n              compressedFile,\r\n              originalSize: file.size,\r\n              compressedSize: compressedFile.size,\r\n              compressionRatio,\r\n              outputFormat,\r\n            });\r\n          }, outputFormat, currentQuality);\r\n        };\r\n\r\n        // Start compression with initial quality\r\n        tryCompress(quality);\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    };\r\n\r\n    img.onerror = () => reject(new Error('Failed to load image'));\r\n    img.src = URL.createObjectURL(file);\r\n  });\r\n}\r\n\r\n// Check if image has transparency (for PNG optimization)\r\nfunction hasTransparency(ctx: CanvasRenderingContext2D | null, width: number, height: number): boolean {\r\n  if (!ctx) return false;\r\n\r\n  try {\r\n    const imageData = ctx.getImageData(0, 0, width, height);\r\n    const data = imageData.data;\r\n\r\n    // Check alpha channel (every 4th value)\r\n    for (let i = 3; i < data.length; i += 4) {\r\n      if (data[i] < 255) {\r\n        return true; // Found transparency\r\n      }\r\n    }\r\n    return false;\r\n  } catch {\r\n    return true; // Assume transparency if we can't check\r\n  }\r\n}\r\n\r\n// Check WebP support\r\nfunction supportsWebP(): boolean {\r\n  const canvas = document.createElement('canvas');\r\n  canvas.width = 1;\r\n  canvas.height = 1;\r\n  return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;\r\n}\r\n\r\n// Get image dimensions\r\nexport async function getImageDimensions(file: File): Promise<{ width: number; height: number }> {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.onload = () => {\r\n      resolve({ width: img.naturalWidth, height: img.naturalHeight });\r\n      URL.revokeObjectURL(img.src);\r\n    };\r\n    img.onerror = () => reject(new Error('Failed to load image'));\r\n    img.src = URL.createObjectURL(file);\r\n  });\r\n}\r\n\r\n// Convert file to base64\r\nexport async function fileToBase64(file: File): Promise<string> {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    reader.onload = () => {\r\n      if (typeof reader.result === 'string') {\r\n        // Remove data URL prefix to get just the base64 data\r\n        const base64 = reader.result.split(',')[1];\r\n        resolve(base64);\r\n      } else {\r\n        reject(new Error('Failed to convert file to base64'));\r\n      }\r\n    };\r\n    reader.onerror = () => reject(new Error('Failed to read file'));\r\n    reader.readAsDataURL(file);\r\n  });\r\n}\r\n\r\n// Create chart image record\r\nexport async function createChartImage(\r\n  file: File,\r\n  shouldCompress: boolean = true\r\n): Promise<{ chartImage: ChartImage; processedFile: File }> {\r\n  const validation = validateImageFile(file);\r\n  if (!validation.isValid) {\r\n    throw new Error(validation.error);\r\n  }\r\n\r\n  let processedFile = file;\r\n  let compressed = false;\r\n  let originalSize = file.size;\r\n\r\n  // Always compress images for better storage efficiency (except very small WebP files)\r\n  const shouldSkipCompression = !shouldCompress ||\r\n    (file.type === 'image/webp' && file.size < 50 * 1024); // Skip only for small WebP files under 50KB\r\n\r\n  if (!shouldSkipCompression) {\r\n    try {\r\n      console.log(`🔄 Starting compression for ${formatFileSize(file.size)} ${file.type} image...`);\r\n      const compressionResult = await compressImage(file);\r\n\r\n      // Only use compressed version if it's actually smaller\r\n      if (compressionResult.compressedSize < file.size) {\r\n        processedFile = compressionResult.compressedFile;\r\n        compressed = true;\r\n        console.log(`📸 Image optimized: ${formatFileSize(originalSize)} → ${formatFileSize(processedFile.size)} (${compressionResult.compressionRatio.toFixed(2)}x) [${compressionResult.outputFormat}]`);\r\n      } else {\r\n        console.log(`📸 Original file is already optimal: ${formatFileSize(file.size)}`);\r\n      }\r\n    } catch (error) {\r\n      console.warn('⚠️ Image compression failed, using original:', error);\r\n    }\r\n  } else {\r\n    console.log(`⏭️ Skipping compression for small ${file.type} file: ${formatFileSize(file.size)}`);\r\n  }\r\n\r\n  const dimensions = await getImageDimensions(processedFile);\r\n\r\n  // PURE SUPABASE: Always use blob storage, no inline storage\r\n  const chartImage: ChartImage = {\r\n    id: generateId(), // Keep using generateId for chart image ID (this is fine)\r\n    filename: file.name,\r\n    mimeType: processedFile.type as any,\r\n    size: processedFile.size,\r\n    uploadedAt: new Date(),\r\n    storage: 'blob', // Always use blob storage for Supabase\r\n    dimensions,\r\n    compressed,\r\n    originalSize: compressed ? originalSize : undefined,\r\n    // Always use UUID for Supabase compatibility\r\n    blobId: uuidv4()\r\n  };\r\n\r\n  return { chartImage, processedFile };\r\n}\r\n\r\n// Utility functions\r\nexport function formatFileSize(bytes: number): string {\r\n  if (bytes === 0) return '0 Bytes';\r\n  const k = 1024;\r\n  const sizes = ['Bytes', 'KB', 'MB', 'GB'];\r\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\r\n}\r\n\r\nexport function getImageDataUrl(chartImage: ChartImage): string | null {\r\n  if (chartImage.storage === 'inline' && chartImage.data) {\r\n    return `data:${chartImage.mimeType};base64,${chartImage.data}`;\r\n  }\r\n  return null;\r\n}\r\n\r\n// Storage size calculation for trade\r\nexport function calculateChartAttachmentsSize(chartAttachments?: any): number {\r\n  if (!chartAttachments) return 0;\r\n\r\n  let totalSize = 0;\r\n  if (chartAttachments.beforeEntry) {\r\n    totalSize += chartAttachments.beforeEntry.size || 0;\r\n  }\r\n  if (chartAttachments.afterExit) {\r\n    totalSize += chartAttachments.afterExit.size || 0;\r\n  }\r\n\r\n  return totalSize;\r\n}\r\n\r\n// Get compression info for display\r\nexport function getCompressionInfo(chartImage: ChartImage): {\r\n  isCompressed: boolean;\r\n  originalSize?: number;\r\n  compressionRatio?: number;\r\n  savedSpace?: number;\r\n  compressionText?: string;\r\n} {\r\n  if (!chartImage.compressed || !chartImage.originalSize) {\r\n    return { isCompressed: false };\r\n  }\r\n\r\n  const compressionRatio = chartImage.originalSize / chartImage.size;\r\n  const savedSpace = chartImage.originalSize - chartImage.size;\r\n  const savedPercentage = ((savedSpace / chartImage.originalSize) * 100).toFixed(0);\r\n\r\n  return {\r\n    isCompressed: true,\r\n    originalSize: chartImage.originalSize,\r\n    compressionRatio,\r\n    savedSpace,\r\n    compressionText: `${savedPercentage}% smaller (${formatFileSize(savedSpace)} saved)`\r\n  };\r\n}\r\n","import { ChartImage, TradeChartAttachments } from '../types/trade';\r\nimport { ChartImageBlob } from '../db/database';\r\nimport { DatabaseService } from '../db/database';\r\nimport { SupabaseService } from './supabaseService';\r\nimport { AuthService } from './authService';\r\nimport { createChartImage, CHART_IMAGE_CONFIG, getImageDataUrl } from '../utils/chartImageUtils';\r\nimport { generateId } from '../utils/helpers';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nexport class ChartImageService {\r\n\r\n  /**\r\n   * Helper function to ensure blob ID is a valid UUID for Supabase\r\n   */\r\n  private static ensureValidBlobId(blobId: string): string {\r\n    // Check if it's already a valid UUID\r\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n    if (uuidRegex.test(blobId)) {\r\n      return blobId;\r\n    }\r\n\r\n    // If not a UUID, generate a new one\r\n    console.log(`🔄 Converting non-UUID blob ID to UUID: ${blobId} -> generating new UUID`);\r\n    return uuidv4();\r\n  }\r\n\r\n  /**\r\n   * Test blob functionality - for debugging\r\n   */\r\n  static async testBlobFunctionality(file: File): Promise<void> {\r\n    console.log('🧪 Testing blob functionality...');\r\n\r\n    // Test 1: Create blob from file\r\n    const testBlob = new Blob([file], { type: file.type });\r\n    console.log(`✅ Test 1 - Blob created: size=${testBlob.size}, type=${testBlob.type}`);\r\n\r\n    // Test 2: Create object URL\r\n    const objectUrl = URL.createObjectURL(testBlob);\r\n    console.log(`✅ Test 2 - Object URL created: ${objectUrl}`);\r\n\r\n    // Test 3: Test if URL works\r\n    const testImg = new Image();\r\n    testImg.onload = () => {\r\n      console.log(`✅ Test 3 - Image loads successfully from blob URL`);\r\n      URL.revokeObjectURL(objectUrl);\r\n    };\r\n    testImg.onerror = (error) => {\r\n      console.error(`❌ Test 3 - Image failed to load from blob URL:`, error);\r\n      URL.revokeObjectURL(objectUrl);\r\n    };\r\n    testImg.src = objectUrl;\r\n  }\r\n\r\n  /**\r\n   * Debug method to check IndexedDB contents\r\n   */\r\n  static async debugIndexedDBContents(): Promise<void> {\r\n    try {\r\n      console.log('🔍 Debugging IndexedDB contents...');\r\n\r\n      // Get all chart image blobs\r\n      const allBlobs = await DatabaseService.getAllChartImageBlobs();\r\n      console.log(`📦 Found ${allBlobs.length} chart image blobs in IndexedDB`);\r\n\r\n      for (const blob of allBlobs) {\r\n        console.log(`🔍 Blob: ${blob.filename}`);\r\n        console.log(`  - ID: ${blob.id}`);\r\n        console.log(`  - Trade ID: ${blob.tradeId}`);\r\n        console.log(`  - Type: ${blob.imageType}`);\r\n        console.log(`  - Size: ${blob.size} bytes`);\r\n        console.log(`  - MIME: ${blob.mimeType}`);\r\n        console.log(`  - Data type: ${blob.data?.constructor.name}`);\r\n        console.log(`  - Data size: ${blob.data?.size} bytes`);\r\n        console.log(`  - Compressed: ${blob.compressed}`);\r\n\r\n        // Try to create object URL\r\n        if (blob.data && blob.data instanceof Blob) {\r\n          try {\r\n            const url = URL.createObjectURL(blob.data);\r\n            console.log(`  - Object URL: ${url.substring(0, 50)}...`);\r\n            URL.revokeObjectURL(url);\r\n          } catch (error) {\r\n            console.error(`  - Failed to create object URL:`, error);\r\n          }\r\n        } else {\r\n          console.error(`  - Invalid blob data!`);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Failed to debug IndexedDB contents:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attach a chart image to a trade\r\n   * NEW: Supports temporary storage for trades that don't exist yet\r\n   */\r\n  static async attachChartImage(\r\n    tradeId: string,\r\n    imageType: 'beforeEntry' | 'afterExit',\r\n    file: File,\r\n    shouldCompress: boolean = true,\r\n    allowTemporary: boolean = true\r\n  ): Promise<{ success: boolean; chartImage?: ChartImage; error?: string; isTemporary?: boolean }> {\r\n    try {\r\n      console.log(`📸 [${imageType.toUpperCase()}] Attaching chart image to trade ${tradeId}: ${file.name} (${file.size} bytes)`);\r\n\r\n      // Create chart image record (this handles compression)\r\n      const { chartImage, processedFile } = await createChartImage(file, shouldCompress);\r\n\r\n      // CRITICAL FIX: Convert processed file to base64 for storage\r\n      const base64Data = await new Promise<string>((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onload = () => {\r\n          if (typeof reader.result === 'string') {\r\n            // Remove data URL prefix to get just the base64 data\r\n            const base64 = reader.result.split(',')[1];\r\n            resolve(base64);\r\n          } else {\r\n            reject(new Error('Failed to convert file to base64'));\r\n          }\r\n        };\r\n        reader.onerror = () => reject(new Error('Failed to read file'));\r\n        reader.readAsDataURL(processedFile);\r\n      });\r\n\r\n      // NEW: Check if this is a temporary upload (trade doesn't exist yet)\r\n      const isTemporaryUpload = tradeId === 'new' || tradeId.startsWith('temp_');\r\n\r\n      console.log(`🔍 [${imageType.toUpperCase()}] Upload parameters:`, {\r\n        tradeId,\r\n        allowTemporary,\r\n        isTemporaryUpload,\r\n        shouldCreateTemporary: isTemporaryUpload && allowTemporary\r\n      });\r\n\r\n      if (isTemporaryUpload && allowTemporary) {\r\n        console.log(`📦 [${imageType.toUpperCase()}] Creating temporary chart image for new trade`);\r\n        // For temporary uploads, just return the chart image without saving to Supabase\r\n        // It will be saved later when the trade is actually created\r\n        return { success: true, chartImage, isTemporary: true };\r\n      }\r\n\r\n      // PURE SUPABASE: Always save to Supabase for existing trades\r\n\r\n      // Check if user is authenticated for Supabase storage\r\n      const isAuthenticated = await AuthService.isAuthenticated();\r\n      if (!isAuthenticated) {\r\n        return { success: false, error: 'User must be authenticated to upload chart images' };\r\n      }\r\n\r\n      // CRITICAL: Ensure the trade exists in Supabase before saving chart image\r\n      // This is required due to foreign key constraint\r\n      const trade = await SupabaseService.getTrade(tradeId);\r\n      if (!trade) {\r\n        if (allowTemporary) {\r\n          console.log(`📦 [${imageType.toUpperCase()}] Trade not found in cloud storage, creating temporary chart image`);\r\n\r\n          // CRITICAL: For temporary charts, we need to ensure they have a dataUrl for immediate preview\r\n          const tempChartImage = {\r\n            ...chartImage,\r\n            dataUrl: `data:${chartImage.mimeType};base64,${base64Data}`,\r\n            isTemporary: true\r\n          };\r\n\r\n          console.log(`📷 [${imageType.toUpperCase()}] Temporary chart created with dataUrl for preview: ${chartImage.filename}`);\r\n          return { success: true, chartImage: tempChartImage, isTemporary: true };\r\n        }\r\n        return { success: false, error: 'Trade not found in cloud storage' };\r\n      }\r\n\r\n      // NEW: Additional check - verify trade actually exists in Supabase trades table\r\n      // We need to check with the converted UUID to ensure foreign key constraint will work\r\n\r\n      // First, convert the trade ID to UUID format (same logic as SupabaseService)\r\n      const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(tradeId);\r\n      let convertedTradeId: string;\r\n\r\n      if (isUUID) {\r\n        convertedTradeId = tradeId;\r\n      } else {\r\n        // Use the EXACT same conversion logic as SupabaseService\r\n        const hash = tradeId.split('').reduce((a, b) => {\r\n          a = ((a << 5) - a) + b.charCodeAt(0);\r\n          return a & a;\r\n        }, 0);\r\n        const hex = Math.abs(hash).toString(16).padStart(8, '0');\r\n        convertedTradeId = `${hex.slice(0, 8)}-${hex.slice(0, 4)}-4${hex.slice(1, 4)}-8${hex.slice(0, 3)}-${hex.slice(0, 12).padEnd(12, '0')}`;\r\n      }\r\n\r\n      console.log(`🔍 [${imageType.toUpperCase()}] Converted trade ID: ${tradeId} → ${convertedTradeId}`);\r\n\r\n      // Now verify the trade exists in Supabase with this exact UUID\r\n      console.log(`🔍 [${imageType.toUpperCase()}] Verifying trade exists in Supabase with UUID: ${convertedTradeId}`);\r\n      const supabaseTrade = await SupabaseService.getTradeFromSupabaseOnly(convertedTradeId);\r\n      if (!supabaseTrade) {\r\n        if (allowTemporary) {\r\n          console.log(`📦 [${imageType.toUpperCase()}] Trade not found in Supabase trades table, creating temporary chart image`);\r\n\r\n          // CRITICAL: For temporary charts, we need to ensure they have a dataUrl for immediate preview\r\n          const tempChartImage = {\r\n            ...chartImage,\r\n            dataUrl: `data:${chartImage.mimeType};base64,${base64Data}`,\r\n            isTemporary: true\r\n          };\r\n\r\n          console.log(`📷 [${imageType.toUpperCase()}] Temporary chart created with dataUrl for preview: ${chartImage.filename}`);\r\n          return { success: true, chartImage: tempChartImage, isTemporary: true };\r\n        }\r\n        return { success: false, error: 'Trade not found in Supabase trades table' };\r\n      }\r\n      console.log(`✅ [${imageType.toUpperCase()}] Trade verified in Supabase:`, supabaseTrade.name || supabaseTrade.id);\r\n\r\n      // Save the trade to Supabase to satisfy foreign key constraint\r\n      try {\r\n        const tradeSaved = await SupabaseService.saveTrade(trade);\r\n        if (!tradeSaved) {\r\n          return { success: false, error: 'Failed to save trade to cloud storage' };\r\n        }\r\n      } catch (tradeError) {\r\n        return { success: false, error: 'Failed to save trade to cloud storage' };\r\n      }\r\n\r\n      // We already have base64Data from above, no need to convert again\r\n      // convertedTradeId is already calculated above\r\n\r\n      const supabaseImageBlob = {\r\n        id: chartImage.blobId, // This is already a UUID from uuidv4()\r\n        trade_id: convertedTradeId, // Use the verified converted UUID\r\n        image_type: imageType,\r\n        filename: chartImage.filename,\r\n        mime_type: chartImage.mimeType,\r\n        size_bytes: chartImage.size,\r\n        data: base64Data, // Use the actual file data we just converted\r\n        uploaded_at: chartImage.uploadedAt.toISOString(),\r\n        compressed: chartImage.compressed || false,\r\n        original_size: chartImage.originalSize\r\n      };\r\n\r\n      console.log(`🔍 [${imageType.toUpperCase()}] Supabase blob data:`, {\r\n        id: supabaseImageBlob.id,\r\n        trade_id: supabaseImageBlob.trade_id,\r\n        image_type: supabaseImageBlob.image_type,\r\n        filename: supabaseImageBlob.filename,\r\n        size_bytes: supabaseImageBlob.size_bytes,\r\n        dataLength: base64Data.length\r\n      });\r\n\r\n\r\n\r\n      const supabaseSaved = await SupabaseService.saveChartImageBlob(supabaseImageBlob);\r\n      if (!supabaseSaved) {\r\n        return { success: false, error: 'Failed to save image to cloud storage' };\r\n      }\r\n\r\n\r\n      // No additional processing needed - everything is handled above\r\n      \r\n      console.log(`✅ [${imageType.toUpperCase()}] Chart image attached successfully: ${chartImage.storage} storage, ${chartImage.size} bytes`);\r\n\r\n      // Test retrieval immediately after saving\r\n      console.log(`🧪 [${imageType.toUpperCase()}] Testing immediate retrieval...`);\r\n      console.log(`🔍 [${imageType.toUpperCase()}] Chart image blob ID for retrieval: ${chartImage.blobId}`);\r\n      console.log(`🔍 [${imageType.toUpperCase()}] Chart image storage type: ${chartImage.storage}`);\r\n\r\n      // Wait a moment for Supabase to process\r\n      await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n      // Test direct Supabase retrieval\r\n      console.log(`🧪 [${imageType.toUpperCase()}] Testing direct Supabase retrieval...`);\r\n      const directBlob = await SupabaseService.getChartImageBlob(chartImage.blobId);\r\n      if (directBlob) {\r\n        console.log(`✅ [${imageType.toUpperCase()}] Direct Supabase retrieval successful: ${directBlob.filename}`);\r\n      } else {\r\n        console.error(`❌ [${imageType.toUpperCase()}] Direct Supabase retrieval failed!`);\r\n      }\r\n\r\n      // Test through service\r\n      const testDataUrl = await ChartImageService.getChartImageDataUrl(chartImage);\r\n      if (testDataUrl) {\r\n        console.log(`✅ [${imageType.toUpperCase()}] Service retrieval successful: ${testDataUrl.substring(0, 50)}...`);\r\n      } else {\r\n        console.error(`❌ [${imageType.toUpperCase()}] Service retrieval failed!`);\r\n        console.error(`❌ [${imageType.toUpperCase()}] Blob ID mismatch? Saved: ${supabaseImageBlob.id}, Retrieving: ${chartImage.blobId}`);\r\n      }\r\n\r\n      // Check if any cleanup processes are running\r\n      console.log(`🔍 [${imageType.toUpperCase()}] Checking for cleanup processes...`);\r\n      setTimeout(async () => {\r\n        const stillExists = await SupabaseService.getChartImageBlob(chartImage.blobId);\r\n        if (stillExists) {\r\n          console.log(`✅ [${imageType.toUpperCase()}] Image still exists after 5 seconds: ${stillExists.filename}`);\r\n        } else {\r\n          console.error(`❌ [${imageType.toUpperCase()}] Image was deleted within 5 seconds! Cleanup process detected.`);\r\n        }\r\n      }, 5000);\r\n\r\n      return { success: true, chartImage, isTemporary: false };\r\n\r\n    } catch (error) {\r\n      console.error('❌ Failed to attach chart image:', error);\r\n      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save temporary chart images to Supabase when trade is created\r\n   * NEW: Helper method to persist temporary charts\r\n   */\r\n  static async saveTemporaryChartImages(\r\n    tradeId: string,\r\n    chartAttachments: any\r\n  ): Promise<{ success: boolean; error?: string }> {\r\n    try {\r\n      if (!chartAttachments) {\r\n        return { success: true };\r\n      }\r\n\r\n      console.log(`💾 [TEMP_SAVE] Saving temporary chart images for trade ${tradeId}`);\r\n\r\n      const isAuthenticated = await AuthService.isAuthenticated();\r\n      if (!isAuthenticated) {\r\n        return { success: false, error: 'User must be authenticated to save chart images' };\r\n      }\r\n\r\n      // Process beforeEntry image\r\n      if (chartAttachments.beforeEntry) {\r\n        const result = await this.saveTemporaryChartImage(tradeId, 'beforeEntry', chartAttachments.beforeEntry);\r\n        if (!result.success) {\r\n          return result;\r\n        }\r\n      }\r\n\r\n      // Process afterExit image\r\n      if (chartAttachments.afterExit) {\r\n        const result = await this.saveTemporaryChartImage(tradeId, 'afterExit', chartAttachments.afterExit);\r\n        if (!result.success) {\r\n          return result;\r\n        }\r\n      }\r\n\r\n      console.log(`✅ [TEMP_SAVE] All temporary chart images saved successfully for trade ${tradeId}`);\r\n      return { success: true };\r\n\r\n    } catch (error) {\r\n      console.error('❌ Failed to save temporary chart images:', error);\r\n      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save a single temporary chart image to Supabase\r\n   * PRIVATE: Helper method for saveTemporaryChartImages\r\n   */\r\n  private static async saveTemporaryChartImage(\r\n    tradeId: string,\r\n    imageType: 'beforeEntry' | 'afterExit',\r\n    chartImage: any\r\n  ): Promise<{ success: boolean; error?: string }> {\r\n    try {\r\n      // Skip if already saved to Supabase (not temporary)\r\n      if (chartImage.storage === 'blob' && chartImage.blobId && !chartImage.isTemporary) {\r\n        console.log(`⏭️ [TEMP_SAVE] Chart image already saved to Supabase: ${chartImage.filename}`);\r\n        return { success: true };\r\n      }\r\n\r\n      console.log(`💾 [TEMP_SAVE] Saving ${imageType} chart image: ${chartImage.filename}`);\r\n\r\n      // Convert inline data to base64 if needed\r\n      let base64Data: string;\r\n      if (chartImage.data) {\r\n        // Remove data URL prefix if present\r\n        base64Data = chartImage.data.replace(/^data:image\\/[a-z]+;base64,/, '');\r\n      } else {\r\n        console.error(`❌ [TEMP_SAVE] No data found for chart image: ${chartImage.filename}`);\r\n        return { success: false, error: 'No image data found' };\r\n      }\r\n\r\n      // Convert trade ID to UUID format for Supabase\r\n      const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(tradeId);\r\n      let convertedTradeId: string;\r\n\r\n      if (isUUID) {\r\n        convertedTradeId = tradeId;\r\n      } else {\r\n        const hash = tradeId.split('').reduce((a, b) => {\r\n          a = ((a << 5) - a) + b.charCodeAt(0);\r\n          return a & a;\r\n        }, 0);\r\n        const hex = Math.abs(hash).toString(16).padStart(8, '0');\r\n        convertedTradeId = `${hex.slice(0, 8)}-${hex.slice(0, 4)}-4${hex.slice(1, 4)}-8${hex.slice(0, 3)}-${hex.slice(0, 12).padEnd(12, '0')}`;\r\n      }\r\n\r\n      // Create Supabase blob record\r\n      const supabaseImageBlob = {\r\n        id: chartImage.blobId || chartImage.id,\r\n        trade_id: convertedTradeId,\r\n        image_type: imageType,\r\n        filename: chartImage.filename,\r\n        mime_type: chartImage.mimeType,\r\n        size_bytes: chartImage.size,\r\n        data: base64Data,\r\n        uploaded_at: chartImage.uploadedAt.toISOString(),\r\n        compressed: chartImage.compressed || false,\r\n        original_size: chartImage.originalSize\r\n      };\r\n\r\n      // Save to Supabase\r\n      const supabaseSaved = await SupabaseService.saveChartImageBlob(supabaseImageBlob);\r\n      if (!supabaseSaved) {\r\n        return { success: false, error: 'Failed to save image to cloud storage' };\r\n      }\r\n\r\n      console.log(`✅ [TEMP_SAVE] Chart image saved to Supabase: ${chartImage.filename}`);\r\n      return { success: true };\r\n\r\n    } catch (error) {\r\n      console.error(`❌ [TEMP_SAVE] Failed to save temporary chart image:`, error);\r\n      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get chart image data URL for display\r\n   */\r\n  static async getChartImageDataUrl(chartImage: ChartImage): Promise<string | null> {\r\n    try {\r\n      // PURE SUPABASE: Handle legacy inline storage but prefer Supabase\r\n      if (chartImage.storage === 'inline' && chartImage.data) {\r\n        return getImageDataUrl(chartImage);\r\n      }\r\n\r\n      // PURE SUPABASE: Always retrieve from Supabase\r\n      if (chartImage.blobId) {\r\n        const isAuthenticated = await AuthService.isAuthenticated();\r\n        if (!isAuthenticated) {\r\n          console.warn('🔐 User not authenticated, cannot load chart image from Supabase');\r\n          return null;\r\n        }\r\n\r\n        try {\r\n          const supabaseBlob = await SupabaseService.getChartImageBlob(chartImage.blobId);\r\n\r\n          if (supabaseBlob) {\r\n\r\n            // Convert Supabase binary data back to blob\r\n            try {\r\n              let bytes: Uint8Array;\r\n\r\n              console.log(`🔍 [RETRIEVAL] Supabase data type:`, typeof supabaseBlob.data);\r\n              console.log(`🔍 [RETRIEVAL] Supabase data constructor:`, supabaseBlob.data?.constructor?.name);\r\n              console.log(`🔍 [RETRIEVAL] Is Array:`, Array.isArray(supabaseBlob.data));\r\n              console.log(`🔍 [RETRIEVAL] Data length:`, supabaseBlob.data?.length);\r\n              console.log(`🔍 [RETRIEVAL] First 10 bytes:`, Array.isArray(supabaseBlob.data) ? supabaseBlob.data.slice(0, 10) : 'N/A');\r\n\r\n              if (typeof supabaseBlob.data === 'string') {\r\n                console.log(`🔍 [RETRIEVAL] String data sample:`, supabaseBlob.data.substring(0, 100));\r\n              }\r\n\r\n              if (supabaseBlob.data instanceof Uint8Array) {\r\n                // Already a Uint8Array - use directly\r\n                console.log(`✅ [RETRIEVAL] Using Uint8Array directly`);\r\n                bytes = supabaseBlob.data;\r\n              } else if (Array.isArray(supabaseBlob.data)) {\r\n                // Array of bytes from Supabase - convert to Uint8Array\r\n                console.log(`✅ [RETRIEVAL] Converting array to Uint8Array`);\r\n                bytes = new Uint8Array(supabaseBlob.data);\r\n              } else if (typeof supabaseBlob.data === 'string') {\r\n                // Supabase bytea can return as hex string (starting with \\x) or base64\r\n                console.log(`⚠️ [RETRIEVAL] String data detected, length: ${supabaseBlob.data.length}`);\r\n                console.log(`🔍 [RETRIEVAL] First 50 chars: ${supabaseBlob.data.substring(0, 50)}`);\r\n\r\n                if (supabaseBlob.data.startsWith('\\\\x')) {\r\n                  // Hex string format from PostgreSQL bytea - but it might be hex-encoded JSON\r\n                  console.log(`✅ [RETRIEVAL] Converting hex string to bytes`);\r\n                  const hexString = supabaseBlob.data.substring(2); // Remove \\x prefix\r\n\r\n                  // First decode the hex to get the actual string\r\n                  let decodedString = '';\r\n                  for (let i = 0; i < hexString.length; i += 2) {\r\n                    const hexByte = hexString.substr(i, 2);\r\n                    decodedString += String.fromCharCode(parseInt(hexByte, 16));\r\n                  }\r\n\r\n                  // Now check if the decoded string is JSON\r\n                  if (decodedString.startsWith('{') || decodedString.startsWith('[')) {\r\n                    try {\r\n                      const parsedData = JSON.parse(decodedString);\r\n                      if (Array.isArray(parsedData) || (typeof parsedData === 'object' && parsedData !== null)) {\r\n                        const arrayData = Array.isArray(parsedData) ? parsedData : Object.values(parsedData);\r\n                        bytes = new Uint8Array(arrayData);\r\n                      } else {\r\n                        throw new Error('Parsed data is not an array or object');\r\n                      }\r\n                    } catch (jsonError) {\r\n                      // Fallback: treat decoded string as raw binary\r\n                      bytes = new Uint8Array(decodedString.length);\r\n                      for (let i = 0; i < decodedString.length; i++) {\r\n                        bytes[i] = decodedString.charCodeAt(i);\r\n                      }\r\n                    }\r\n                  } else {\r\n                    // Decoded hex is raw binary data\r\n                    bytes = new Uint8Array(decodedString.length);\r\n                    for (let i = 0; i < decodedString.length; i++) {\r\n                      bytes[i] = decodedString.charCodeAt(i);\r\n                    }\r\n                  }\r\n                } else {\r\n                  // The data might be a JSON string representation of an array\r\n                  try {\r\n                    const parsedData = JSON.parse(supabaseBlob.data);\r\n                    if (Array.isArray(parsedData) || (typeof parsedData === 'object' && parsedData !== null)) {\r\n                      // Convert object with numeric keys to array\r\n                      const arrayData = Array.isArray(parsedData) ? parsedData : Object.values(parsedData);\r\n                      bytes = new Uint8Array(arrayData);\r\n                    } else {\r\n                      throw new Error('Parsed data is not an array or object');\r\n                    }\r\n                  } catch (jsonError) {\r\n                    try {\r\n                      const binaryString = atob(supabaseBlob.data);\r\n                      bytes = new Uint8Array(binaryString.length);\r\n                      for (let i = 0; i < binaryString.length; i++) {\r\n                        bytes[i] = binaryString.charCodeAt(i);\r\n                      }\r\n                    } catch (base64Error) {\r\n                      // Last resort: treat as raw string\r\n                      bytes = new Uint8Array(supabaseBlob.data.length);\r\n                      for (let i = 0; i < supabaseBlob.data.length; i++) {\r\n                        bytes[i] = supabaseBlob.data.charCodeAt(i);\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              } else {\r\n                throw new Error(`Unsupported data format from Supabase: ${typeof supabaseBlob.data}`);\r\n              }\r\n\r\n              const blobData = new Blob([bytes], { type: supabaseBlob.mime_type });\r\n\r\n              // Validate blob data\r\n              if (!blobData || blobData.size === 0) {\r\n                return null;\r\n              }\r\n\r\n              // Convert Uint8Array to base64 string\r\n              let base64String = '';\r\n              const chunkSize = 8192; // Process in chunks to avoid call stack overflow\r\n              for (let i = 0; i < bytes.length; i += chunkSize) {\r\n                const chunk = bytes.slice(i, i + chunkSize);\r\n                base64String += String.fromCharCode.apply(null, Array.from(chunk));\r\n              }\r\n              const base64Data = btoa(base64String);\r\n\r\n              const dataUrl = `data:${supabaseBlob.mime_type};base64,${base64Data}`;\r\n\r\n              return dataUrl;\r\n            } catch (decodeError) {\r\n              return null;\r\n            }\r\n          } else {\r\n            console.warn(`📷 Chart image blob not found in Supabase: ${chartImage.blobId}`);\r\n            return null;\r\n          }\r\n        } catch (error) {\r\n          console.error(`❌ Error loading chart image from Supabase:`, error);\r\n          return null;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Delete a chart image\r\n   */\r\n  static async deleteChartImage(\r\n    tradeId: string,\r\n    imageType: 'beforeEntry' | 'afterExit',\r\n    chartImage: ChartImage\r\n  ): Promise<boolean> {\r\n    try {\r\n      // PURE SUPABASE: Delete from Supabase if user is authenticated\r\n      if (chartImage.storage === 'blob' && chartImage.blobId) {\r\n        const isAuthenticated = await AuthService.isAuthenticated();\r\n        if (isAuthenticated) {\r\n          await SupabaseService.deleteChartImageBlob(chartImage.blobId);\r\n        }\r\n      }\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Delete all chart images for a trade\r\n   */\r\n  static async deleteTradeChartImages(tradeId: string): Promise<boolean> {\r\n    try {\r\n      // Delete all blob storage for this trade\r\n      await DatabaseService.deleteTradeChartImageBlobs(tradeId);\r\n\r\n      return true;\r\n\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get storage statistics for chart images\r\n   */\r\n  static async getStorageStats(): Promise<{\r\n    totalImages: number;\r\n    totalSize: number;\r\n    inlineImages: number;\r\n    inlineSize: number;\r\n    blobImages: number;\r\n    blobSize: number;\r\n  }> {\r\n    try {\r\n      const allBlobs = await DatabaseService.getAllChartImageBlobs();\r\n      const blobSize = allBlobs.reduce((total, blob) => total + blob.size, 0);\r\n      \r\n      // Note: We can't easily calculate inline image sizes without loading all trades\r\n      // This would be a performance concern, so we'll estimate based on blob data\r\n      \r\n      return {\r\n        totalImages: allBlobs.length,\r\n        totalSize: blobSize,\r\n        inlineImages: 0, // Would need to scan all trades to calculate\r\n        inlineSize: 0,   // Would need to scan all trades to calculate\r\n        blobImages: allBlobs.length,\r\n        blobSize: blobSize,\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        totalImages: 0,\r\n        totalSize: 0,\r\n        inlineImages: 0,\r\n        inlineSize: 0,\r\n        blobImages: 0,\r\n        blobSize: 0,\r\n      };\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Cleanup orphaned chart image blobs (blobs without corresponding trades)\r\n   * PURE SUPABASE: Updated to work with Supabase data\r\n   */\r\n  static async cleanupOrphanedBlobs(): Promise<{ cleaned: number; errors: number }> {\r\n    try {\r\n      // Check if user is authenticated for Supabase operations\r\n      const isAuthenticated = await AuthService.isAuthenticated();\r\n      if (!isAuthenticated) {\r\n        return { cleaned: 0, errors: 0 };\r\n      }\r\n\r\n      // PURE SUPABASE: Get data from Supabase, not IndexedDB\r\n      const [allBlobs, allTrades] = await Promise.all([\r\n        SupabaseService.getAllChartImageBlobs(),\r\n        SupabaseService.getAllTrades()\r\n      ]);\r\n\r\n      // Convert trade IDs to the same format used in chart images (UUID conversion)\r\n      const tradeIds = new Set();\r\n\r\n      for (const trade of allTrades) {\r\n        // Add both original ID and converted UUID to handle both formats\r\n        tradeIds.add(trade.id);\r\n\r\n        // Also add the UUID conversion if it's different\r\n        const convertedId = this.convertTradeIdToUUID(trade.id);\r\n        if (convertedId !== trade.id) {\r\n          tradeIds.add(convertedId);\r\n        }\r\n      }\r\n\r\n      let cleaned = 0;\r\n      let errors = 0;\r\n\r\n      for (const blob of allBlobs) {\r\n        if (!tradeIds.has(blob.trade_id)) {\r\n          // TEMPORARILY DISABLE actual deletion for debugging\r\n          // const deleted = await SupabaseService.deleteChartImageBlob(blob.id);\r\n          // if (deleted) {\r\n          //   cleaned++;\r\n          // } else {\r\n          //   errors++;\r\n          // }\r\n        }\r\n      }\r\n\r\n      return { cleaned, errors };\r\n\r\n    } catch (error) {\r\n      return { cleaned: 0, errors: 1 };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Helper method to convert trade ID to UUID (same logic as used in chart image service)\r\n   */\r\n  private static convertTradeIdToUUID(tradeId: string): string {\r\n    // If it's already a UUID format, return as is\r\n    if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(tradeId)) {\r\n      return tradeId;\r\n    }\r\n\r\n    // Create a deterministic UUID from the string ID\r\n    const hash = tradeId.split('').reduce((a, b) => {\r\n      a = ((a << 5) - a) + b.charCodeAt(0);\r\n      return a & a;\r\n    }, 0);\r\n\r\n    // Convert hash to UUID format\r\n    const hex = Math.abs(hash).toString(16).padStart(8, '0');\r\n    return `${hex.slice(0, 8)}-${hex.slice(0, 4)}-4${hex.slice(1, 4)}-8${hex.slice(0, 3)}-${hex.slice(0, 12).padEnd(12, '0')}`;\r\n  }\r\n\r\n  /**\r\n   * Cleanup orphaned chart attachments in trade records (references without corresponding blobs)\r\n   * PURE SUPABASE: Updated to work with Supabase data\r\n   */\r\n  static async cleanupOrphanedAttachments(): Promise<{ cleaned: number; errors: number }> {\r\n    try {\r\n      // Check if user is authenticated for Supabase operations\r\n      const isAuthenticated = await AuthService.isAuthenticated();\r\n      if (!isAuthenticated) {\r\n        return { cleaned: 0, errors: 0 };\r\n      }\r\n\r\n      // PURE SUPABASE: Get data from Supabase, not IndexedDB\r\n      const [allTrades, allBlobs] = await Promise.all([\r\n        SupabaseService.getAllTrades(),\r\n        SupabaseService.getAllChartImageBlobs()\r\n      ]);\r\n\r\n      const blobIds = new Set(allBlobs.map(blob => blob.id));\r\n\r\n      let cleaned = 0;\r\n      let errors = 0;\r\n\r\n      for (const trade of allTrades) {\r\n        if (!trade.chartAttachments) continue;\r\n\r\n        let needsUpdate = false;\r\n        const updatedAttachments = { ...trade.chartAttachments };\r\n\r\n        // Check beforeEntry attachment\r\n        if (updatedAttachments.beforeEntry) {\r\n          const attachment = updatedAttachments.beforeEntry;\r\n          if (attachment.storage === 'blob' && attachment.blobId && !blobIds.has(attachment.blobId)) {\r\n            delete updatedAttachments.beforeEntry;\r\n            needsUpdate = true;\r\n          }\r\n        }\r\n\r\n        // Check afterExit attachment\r\n        if (updatedAttachments.afterExit) {\r\n          const attachment = updatedAttachments.afterExit;\r\n          if (attachment.storage === 'blob' && attachment.blobId && !blobIds.has(attachment.blobId)) {\r\n            delete updatedAttachments.afterExit;\r\n            needsUpdate = true;\r\n          }\r\n        }\r\n\r\n        if (needsUpdate) {\r\n          // Check if any attachments remain\r\n          const hasRemainingAttachments = updatedAttachments.beforeEntry || updatedAttachments.afterExit;\r\n\r\n          const updatedTrade = {\r\n            ...trade,\r\n            chartAttachments: hasRemainingAttachments ? {\r\n              ...updatedAttachments,\r\n              metadata: {\r\n                ...updatedAttachments.metadata,\r\n                updatedAt: new Date(),\r\n                totalSize: (updatedAttachments.beforeEntry?.size || 0) + (updatedAttachments.afterExit?.size || 0)\r\n              }\r\n            } : undefined\r\n          };\r\n\r\n          // PURE SUPABASE: Save to Supabase, not IndexedDB\r\n          const saved = await SupabaseService.saveTrade(updatedTrade);\r\n          if (saved) {\r\n            cleaned++;\r\n          } else {\r\n            errors++;\r\n          }\r\n        }\r\n      }\r\n\r\n      return { cleaned, errors };\r\n\r\n    } catch (error) {\r\n      return { cleaned: 0, errors: 1 };\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Comprehensive cleanup of all orphaned chart data\r\n   */\r\n  static async cleanupAllOrphanedData(): Promise<{\r\n    blobsCleaned: number;\r\n    attachmentsCleaned: number;\r\n    errors: number\r\n  }> {\r\n    try {\r\n      // First cleanup orphaned blobs\r\n      const blobCleanup = await this.cleanupOrphanedBlobs();\r\n\r\n      // Then cleanup orphaned attachments in trade records\r\n      const attachmentCleanup = await this.cleanupOrphanedAttachments();\r\n\r\n      const totalErrors = blobCleanup.errors + attachmentCleanup.errors;\r\n\r\n      return {\r\n        blobsCleaned: blobCleanup.cleaned,\r\n        attachmentsCleaned: attachmentCleanup.cleaned,\r\n        errors: totalErrors\r\n      };\r\n\r\n    } catch (error) {\r\n      return { blobsCleaned: 0, attachmentsCleaned: 0, errors: 1 };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate chart attachments data structure\r\n   */\r\n  static validateChartAttachments(chartAttachments: any): chartAttachments is TradeChartAttachments {\r\n    if (!chartAttachments || typeof chartAttachments !== 'object') {\r\n      return false;\r\n    }\r\n\r\n    // Check beforeEntry if present\r\n    if (chartAttachments.beforeEntry && !this.validateChartImage(chartAttachments.beforeEntry)) {\r\n      return false;\r\n    }\r\n\r\n    // Check afterExit if present\r\n    if (chartAttachments.afterExit && !this.validateChartImage(chartAttachments.afterExit)) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Validate chart image data structure\r\n   */\r\n  private static validateChartImage(chartImage: any): chartImage is ChartImage {\r\n    return (\r\n      chartImage &&\r\n      typeof chartImage === 'object' &&\r\n      typeof chartImage.id === 'string' &&\r\n      typeof chartImage.filename === 'string' &&\r\n      typeof chartImage.mimeType === 'string' &&\r\n      typeof chartImage.size === 'number' &&\r\n      chartImage.uploadedAt instanceof Date &&\r\n      (chartImage.storage === 'inline' || chartImage.storage === 'blob') &&\r\n      CHART_IMAGE_CONFIG.ALLOWED_TYPES.includes(chartImage.mimeType)\r\n    );\r\n  }\r\n}\r\n"],"names":["generateId","Math","random","toString","substring","getFromIndexedDB","async","key","fallback","parser","stored","SupabaseService","getMiscData","error","setToIndexedDB","value","serializer","valueToStore","saveMiscData","byteToHex","i","push","slice","getRandomValues","rnds8","Uint8Array","native","randomUUID","crypto","bind","v4","options","buf","offset","rnds","_a","rng","Error","length","arr","toLowerCase","unsafeStringify","CHART_IMAGE_CONFIG","MAX_FILE_SIZE","INLINE_THRESHOLD","COMPRESSION_QUALITY","WEBP_QUALITY","HIGH_COMPRESSION_QUALITY","ULTRA_COMPRESSION_QUALITY","MAX_DIMENSION","LARGE_FILE_MAX_DIMENSION","HUGE_FILE_MAX_DIMENSION","AGGRESSIVE_COMPRESSION_THRESHOLD","HIGH_COMPRESSION_THRESHOLD","ULTRA_COMPRESSION_THRESHOLD","ALLOWED_TYPES","ALLOWED_EXTENSIONS","PROGRESSIVE_JPEG","TARGET_SIZE_SMALL","TARGET_SIZE_MEDIUM","TARGET_SIZE_LARGE","validateImageFile","file","result","isValid","warnings","size","formatFileSize","includes","type","join","extension","name","lastIndexOf","supportsWebP","canvas","document","createElement","width","height","toDataURL","indexOf","createChartImage","shouldCompress","validation","processedFile","compressed","originalSize","console","log","compressionResult","maxDimension","customQuality","Promise","resolve","reject","ctx","getContext","img","Image","onload","outputFormat","quality","effectiveMaxDimension","min","ratio","round","imageSmoothingEnabled","imageSmoothingQuality","drawImage","isUltraLarge","isLarge","isModerate","data","getImageData","hasTransparency","tryCompress","currentQuality","attempt","toBlob","blob","compressedFile","File","lastModified","Date","now","targetSize","newQuality","max","toFixed","compressionRatio","compressedSize","onerror","src","URL","createObjectURL","compressImage","warn","dimensions","naturalWidth","naturalHeight","revokeObjectURL","getImageDimensions","chartImage","id","filename","mimeType","uploadedAt","storage","blobId","uuidv4","bytes","floor","parseFloat","pow","getCompressionInfo","isCompressed","savedSpace","savedPercentage","compressionText","ChartImageService","ensureValidBlobId","test","testBlobFunctionality","testBlob","Blob","objectUrl","testImg","debugIndexedDBContents","allBlobs","DatabaseService","getAllChartImageBlobs","tradeId","imageType","constructor","_b","url","attachChartImage","allowTemporary","toUpperCase","base64Data","reader","FileReader","base64","split","readAsDataURL","isTemporaryUpload","startsWith","shouldCreateTemporary","success","isTemporary","AuthService","isAuthenticated","trade","getTrade","tempChartImage","dataUrl","convertedTradeId","hash","reduce","a","b","charCodeAt","hex","abs","padStart","padEnd","supabaseTrade","getTradeFromSupabaseOnly","saveTrade","tradeError","supabaseImageBlob","trade_id","image_type","mime_type","size_bytes","uploaded_at","toISOString","original_size","dataLength","saveChartImageBlob","setTimeout","directBlob","getChartImageBlob","testDataUrl","getChartImageDataUrl","stillExists","message","saveTemporaryChartImages","chartAttachments","beforeEntry","this","saveTemporaryChartImage","afterExit","replace","getImageDataUrl","supabaseBlob","Array","isArray","_c","hexString","decodedString","hexByte","substr","String","fromCharCode","parseInt","parsedData","JSON","parse","arrayData","Object","values","jsonError","binaryString","atob","base64Error","blobData","base64String","chunkSize","chunk","apply","from","btoa","decodeError","deleteChartImage","deleteChartImageBlob","deleteTradeChartImages","deleteTradeChartImageBlobs","getStorageStats","blobSize","total","totalImages","totalSize","inlineImages","inlineSize","blobImages","cleanupOrphanedBlobs","cleaned","errors","allTrades","all","getAllTrades","tradeIds","Set","add","convertedId","convertTradeIdToUUID","has","cleanupOrphanedAttachments","blobIds","map","needsUpdate","updatedAttachments","attachment","hasRemainingAttachments","updatedTrade","metadata","updatedAt","cleanupAllOrphanedData","blobCleanup","attachmentCleanup","totalErrors","blobsCleaned","attachmentsCleaned","validateChartAttachments","validateChartImage"],"mappings":"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","x_google_ignoreList":[1,2,3,4]}