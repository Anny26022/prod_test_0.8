{"version":3,"file":"use-accounting-calculations-2iOnH437.js","sources":["../../src/hooks/use-accounting-calculations.ts"],"sourcesContent":["import { useMemo, useCallback } from 'react';\r\nimport { Trade } from '../types/trade';\r\nimport { useAccountingMethod } from '../context/AccountingMethodContext';\r\nimport { calculateTradePL, getTradeDateForAccounting } from '../utils/accountingUtils';\r\nimport { calcHoldingDays } from '../utils/tradeCalculations';\r\n\r\n/**\r\n * Shared hook for accounting-aware P/L calculations\r\n * Eliminates redundant calculations across components\r\n */\r\nexport const useAccountingCalculations = (trades: Trade[]) => {\r\n  const { accountingMethod } = useAccountingMethod();\r\n  const useCashBasis = accountingMethod === 'cash';\r\n\r\n  // Memoized P/L calculation function\r\n  const calculateAccountingPL = useCallback((trade: Trade) => {\r\n    // For cash basis with expanded trades, sum up all the individual exit P/Ls\r\n    if (useCashBasis && trade._expandedTrades && trade._expandedTrades.length > 0) {\r\n      return trade._expandedTrades.reduce((sum, expandedTrade) => {\r\n        return sum + calculateTradePL(expandedTrade, true);\r\n      }, 0);\r\n    }\r\n    return calculateTradePL(trade, useCashBasis);\r\n  }, [useCashBasis]);\r\n\r\n  // Memoized calculations to prevent unnecessary re-computations\r\n  const calculations = useMemo(() => {\r\n    // Handle edge cases\r\n    if (!trades || trades.length === 0) {\r\n      return {\r\n        tradesWithAccountingPL: [],\r\n        totalTrades: 0,\r\n        winningTrades: [],\r\n        losingTrades: [],\r\n        winRate: 0,\r\n        grossPL: 0,\r\n        avgGain: 0,\r\n        avgLoss: 0,\r\n        avgPosMove: 0,\r\n        avgNegMove: 0,\r\n        avgPositionSize: 0,\r\n        avgHoldingDays: 0,\r\n        avgR: 0,\r\n        planFollowed: 0,\r\n        openPositions: 0,\r\n        useCashBasis,\r\n        accountingMethod\r\n      };\r\n    }\r\n\r\n    // CRITICAL FIX: Use the same logic as main stats calculation for cash basis\r\n    let tradesWithAccountingPL;\r\n    if (useCashBasis) {\r\n      // For cash basis: Get all expanded trades that have _cashBasisExit\r\n      const realizedTradesFlat = trades.flatMap(trade =>\r\n        Array.isArray(trade._expandedTrades)\r\n          ? trade._expandedTrades.filter(t => t._cashBasisExit)\r\n          : (trade._cashBasisExit ? [trade] : [])\r\n      );\r\n\r\n      // Group by original ID and calculate total P/L per original trade\r\n      const tradeGroups = new Map<string, Trade[]>();\r\n      realizedTradesFlat.forEach(trade => {\r\n        const originalId = trade.id.split('_exit_')[0];\r\n        if (!tradeGroups.has(originalId)) {\r\n          tradeGroups.set(originalId, []);\r\n        }\r\n        tradeGroups.get(originalId)!.push(trade);\r\n      });\r\n\r\n      // Calculate total P/L for each original trade\r\n      tradesWithAccountingPL = Array.from(tradeGroups.entries()).map(([originalId, trades]) => {\r\n        // Sum up P/L from all exits for this trade\r\n        const totalPL = trades.reduce((sum, trade) => {\r\n          return sum + calculateTradePL(trade, useCashBasis);\r\n        }, 0);\r\n\r\n        // Use the first trade as the representative (they all have the same original data)\r\n        const representativeTrade = trades[0];\r\n\r\n        try {\r\n          return {\r\n            ...representativeTrade,\r\n            id: originalId, // Use original ID\r\n            accountingPL: totalPL\r\n          };\r\n        } catch (error) {\r\n          return {\r\n            ...representativeTrade,\r\n            id: originalId,\r\n            accountingPL: 0\r\n          };\r\n        }\r\n      });\r\n    } else {\r\n      // For accrual basis: Use trades as-is\r\n      tradesWithAccountingPL = trades.map(trade => {\r\n        try {\r\n          return {\r\n            ...trade,\r\n            accountingPL: calculateAccountingPL(trade)\r\n          };\r\n        } catch (error) {\r\n          return {\r\n            ...trade,\r\n            accountingPL: 0\r\n          };\r\n        }\r\n      });\r\n    }\r\n\r\n    // Basic statistics\r\n    const totalTrades = tradesWithAccountingPL.length;\r\n    const winningTrades = tradesWithAccountingPL.filter(t => t.accountingPL > 0);\r\n    const losingTrades = tradesWithAccountingPL.filter(t => t.accountingPL < 0);\r\n    const winRate = totalTrades > 0 ? (winningTrades.length / totalTrades) * 100 : 0;\r\n\r\n    // P/L calculations\r\n    const grossPL = tradesWithAccountingPL.reduce((sum, trade) => sum + trade.accountingPL, 0);\r\n    const avgGain = winningTrades.length > 0\r\n      ? winningTrades.reduce((sum, t) => sum + t.accountingPL, 0) / winningTrades.length\r\n      : 0;\r\n    const avgLoss = losingTrades.length > 0\r\n      ? losingTrades.reduce((sum, t) => sum + t.accountingPL, 0) / losingTrades.length\r\n      : 0;\r\n\r\n    // Stock move calculations (for performance metrics)\r\n    const avgPosMove = winningTrades.length > 0\r\n      ? winningTrades.reduce((sum, t) => sum + (t.stockMove || 0), 0) / winningTrades.length\r\n      : 0;\r\n    const avgNegMove = losingTrades.length > 0\r\n      ? losingTrades.reduce((sum, t) => sum + (t.stockMove || 0), 0) / losingTrades.length\r\n      : 0;\r\n\r\n    // Position size and holding period calculations\r\n    const avgPositionSize = totalTrades > 0\r\n      ? tradesWithAccountingPL.reduce((sum, t) => sum + (t.allocation || 0), 0) / totalTrades\r\n      : 0;\r\n\r\n    // Average holding days - always use FIFO logic regardless of accounting method\r\n    const avgHoldingDays = totalTrades > 0\r\n      ? tradesWithAccountingPL.reduce((sum, trade) => {\r\n          // Use existing FIFO-based calcHoldingDays function\r\n          const pyramidDates = [\r\n            { date: trade.pyramid1Date, qty: trade.pyramid1Qty || 0 },\r\n            { date: trade.pyramid2Date, qty: trade.pyramid2Qty || 0 }\r\n          ].filter(p => p.date && p.date.trim() !== '' && p.qty > 0);\r\n\r\n          const exitDates = [\r\n            { date: trade.exit1Date, qty: trade.exit1Qty || 0 },\r\n            { date: trade.exit2Date, qty: trade.exit2Qty || 0 },\r\n            { date: trade.exit3Date, qty: trade.exit3Qty || 0 }\r\n          ].filter(e => e.date && e.date.trim() !== '' && e.qty > 0);\r\n\r\n          // Find primary exit date for closed trades\r\n          let primaryExitDate: string | null = null;\r\n          if (trade.positionStatus === 'Closed' || trade.positionStatus === 'Partial') {\r\n            const validExitDates = [trade.exit1Date, trade.exit2Date, trade.exit3Date]\r\n              .filter(Boolean) as string[];\r\n            if (validExitDates.length > 0) {\r\n              primaryExitDate = validExitDates.sort((a, b) =>\r\n                new Date(a).getTime() - new Date(b).getTime()\r\n              )[0];\r\n            }\r\n          }\r\n\r\n          const fifoHoldingDays = calcHoldingDays(\r\n            trade.date,\r\n            primaryExitDate,\r\n            pyramidDates,\r\n            exitDates\r\n          );\r\n\r\n          return sum + fifoHoldingDays;\r\n        }, 0) / totalTrades\r\n      : 0;\r\n\r\n    // Risk-reward calculations\r\n    const avgR = totalTrades > 0\r\n      ? tradesWithAccountingPL.reduce((sum, trade) => {\r\n          const r = trade.r || 0;\r\n          return sum + r;\r\n        }, 0) / totalTrades\r\n      : 0;\r\n\r\n    // Plan adherence\r\n    const planFollowed = totalTrades > 0\r\n      ? (tradesWithAccountingPL.filter(t => t.planFollowed).length / totalTrades) * 100\r\n      : 0;\r\n\r\n    // Open positions - use positionStatus instead of exitDate (already using deduplicated trades)\r\n    const openPositions = tradesWithAccountingPL.filter(t =>\r\n      t.positionStatus === 'Open' || t.positionStatus === 'Partial'\r\n    ).length;\r\n\r\n    return {\r\n      tradesWithAccountingPL,\r\n      totalTrades,\r\n      winningTrades,\r\n      losingTrades,\r\n      winRate,\r\n      grossPL,\r\n      avgGain,\r\n      avgLoss,\r\n      avgPosMove,\r\n      avgNegMove,\r\n      avgPositionSize,\r\n      avgHoldingDays,\r\n      avgR,\r\n      planFollowed,\r\n      openPositions,\r\n      useCashBasis,\r\n      accountingMethod\r\n    };\r\n  }, [trades, calculateAccountingPL, useCashBasis, accountingMethod]);\r\n\r\n  return calculations;\r\n};\r\n\r\n/**\r\n * Hook for getting accounting method display information\r\n */\r\nexport const useAccountingMethodDisplay = () => {\r\n  const { accountingMethod } = useAccountingMethod();\r\n  const useCashBasis = accountingMethod === 'cash';\r\n\r\n  return {\r\n    accountingMethod,\r\n    useCashBasis,\r\n    displayName: useCashBasis ? 'Cash Basis' : 'Accrual Basis',\r\n    description: useCashBasis\r\n      ? 'P/L attributed to exit dates'\r\n      : 'P/L attributed to entry dates',\r\n    shortDescription: useCashBasis ? 'Exit-based' : 'Entry-based'\r\n  };\r\n};\r\n"],"names":["useAccountingCalculations","trades","accountingMethod","useAccountingMethod","useCashBasis","calculateAccountingPL","useCallback","trade","_expandedTrades","length","reduce","sum","expandedTrade","calculateTradePL","useMemo","tradesWithAccountingPL","totalTrades","winningTrades","losingTrades","winRate","grossPL","avgGain","avgLoss","avgPosMove","avgNegMove","avgPositionSize","avgHoldingDays","avgR","planFollowed","openPositions","realizedTradesFlat","flatMap","Array","isArray","filter","t","_cashBasisExit","tradeGroups","Map","forEach","originalId","id","split","has","set","get","push","from","entries","map","totalPL","representativeTrade","accountingPL","error","stockMove","allocation","pyramidDates","date","pyramid1Date","qty","pyramid1Qty","pyramid2Date","pyramid2Qty","p","trim","exitDates","exit1Date","exit1Qty","exit2Date","exit2Qty","exit3Date","exit3Qty","e","primaryExitDate","positionStatus","validExitDates","Boolean","sort","a","b","Date","getTime","calcHoldingDays","r","useAccountingMethodDisplay","displayName","description","shortDescription"],"mappings":"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"}