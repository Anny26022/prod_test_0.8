{"version":3,"file":"virtualization-XEk1mQjT.js","sources":["../../node_modules/@tanstack/virtual-core/dist/esm/utils.js","../../node_modules/@tanstack/virtual-core/dist/esm/index.js","../../node_modules/@tanstack/react-virtual/dist/esm/index.js"],"sourcesContent":["function memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  function memoizedFunction() {\n    var _a, _b, _c, _d;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n    return result;\n  }\n  memoizedFunction.updateDeps = (newDeps) => {\n    deps = newDeps;\n  };\n  return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) <= 1;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\nexport {\n  approxEqual,\n  debounce,\n  memo,\n  notUndefined\n};\n//# sourceMappingURL=utils.js.map\n","import { debounce, memo, notUndefined, approxEqual } from \"./utils.js\";\nconst getRect = (element) => {\n  const { offsetWidth, offsetHeight } = element;\n  return { width: offsetWidth, height: offsetHeight };\n};\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(getRect(element));\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0];\n      if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize });\n          return;\n        }\n      }\n      handler(getRect(element));\n    };\n    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst addEventListenerOptions = {\n  passive: true\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    const { horizontal, isRtl } = instance.options;\n    offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return element[instance.options.horizontal ? \"offsetWidth\" : \"offsetHeight\"];\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            const run = () => {\n              this._measureElement(entry.target, entry);\n            };\n            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          (_a = get()) == null ? void 0 : _a.disconnect();\n          _ro = null;\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        useScrollendEvent: false,\n        useAnimationFrameWithResizeObserver: false,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.observer.disconnect();\n      this.scrollElement = null;\n      this.targetWindow = null;\n    };\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a;\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        if (!scrollElement) {\n          this.maybeNotify();\n          return;\n        }\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n        this.elementsCache.forEach((cached) => {\n          this.observer.observe(cached);\n        });\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset;\n            this.isScrolling = isScrolling;\n            this.maybeNotify();\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n      this.scrollRect = this.scrollRect ?? this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getScrollOffset = () => {\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n      return this.scrollOffset;\n    };\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurementOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey,\n          enabled\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getMeasurements = memo(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {\n        if (!enabled) {\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          return [];\n        }\n        if (this.measurementsCache.length === 0) {\n          this.measurementsCache = this.options.initialMeasurementsCache;\n          this.measurementsCache.forEach((item) => {\n            this.itemSizeCache.set(item.key, item.size);\n          });\n        }\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [\n        this.getMeasurements(),\n        this.getSize(),\n        this.getScrollOffset(),\n        this.options.lanes\n      ],\n      (measurements, outerSize, scrollOffset, lanes) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset,\n          lanes\n        }) : null;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualIndexes = memo(\n      () => {\n        let startIndex = null;\n        let endIndex = null;\n        const range = this.calculateRange();\n        if (range) {\n          startIndex = range.startIndex;\n          endIndex = range.endIndex;\n        }\n        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);\n        return [\n          this.options.rangeExtractor,\n          this.options.overscan,\n          this.options.count,\n          startIndex,\n          endIndex\n        ];\n      },\n      (rangeExtractor, overscan, count, startIndex, endIndex) => {\n        return startIndex === null || endIndex === null ? [] : rangeExtractor({\n          startIndex,\n          endIndex,\n          overscan,\n          count\n        });\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const index = this.indexFromElement(node);\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const key = item.key;\n      const prevNode = this.elementsCache.get(key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n      if (node.isConnected) {\n        this.resizeItem(index, this.options.measureElement(node, entry, this));\n      }\n    };\n    this.resizeItem = (index, size) => {\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : this.scrollDirection === \"backward\" && item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getVirtualIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualItems\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      if (measurements.length === 0) {\n        return void 0;\n      }\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => notUndefined(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        align = toOffset >= scrollOffset + size ? \"end\" : \"start\";\n      }\n      if (align === \"center\") {\n        toOffset += (itemSize - size) / 2;\n      } else if (align === \"end\") {\n        toOffset -= size;\n      }\n      const maxOffset = this.getTotalSize() - size;\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return void 0;\n      }\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n      return [\n        this.getOffsetForAlignment(toOffset, align, item.size),\n        align\n      ];\n    };\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      const offsetAndAlign = this.getOffsetForIndex(index, initialAlign);\n      if (!offsetAndAlign) return;\n      const [offset, align] = offsetAndAlign;\n      this._scrollToOffset(offset, { adjustments: void 0, behavior });\n      if (behavior !== \"smooth\" && this.isDynamicMode() && this.targetWindow) {\n        this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.elementsCache.has(\n            this.options.getItemKey(index)\n          );\n          if (elementInDOM) {\n            const result = this.getOffsetForIndex(index, align);\n            if (!result) return;\n            const [latestOffset] = result;\n            const currentScrollOffset = this.getScrollOffset();\n            if (!approxEqual(latestOffset, currentScrollOffset)) {\n              this.scrollToIndex(index, { align, behavior });\n            }\n          } else {\n            this.scrollToIndex(index, { align, behavior });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else if (this.options.lanes === 1) {\n        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;\n      } else {\n        const endByLane = Array(this.options.lanes).fill(null);\n        let endIndex = measurements.length - 1;\n        while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n          const item = measurements[endIndex];\n          if (endByLane[item.lane] === null) {\n            endByLane[item.lane] = item.end;\n          }\n          endIndex--;\n        }\n        end = Math.max(...endByLane.filter((val) => val !== null));\n      }\n      return Math.max(\n        end - this.options.scrollMargin + this.options.paddingEnd,\n        0\n      );\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes\n}) {\n  const lastIndex = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex\n    };\n  }\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset\n  );\n  let endIndex = startIndex;\n  if (lanes === 1) {\n    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {\n      endIndex++;\n    }\n  } else if (lanes > 1) {\n    const endPerLane = Array(lanes).fill(0);\n    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {\n      const item = measurements[endIndex];\n      endPerLane[item.lane] = item.end;\n      endIndex++;\n    }\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex];\n      startPerLane[item.lane] = item.start;\n      startIndex--;\n    }\n    startIndex = Math.max(0, startIndex - startIndex % lanes);\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n  }\n  return { startIndex, endIndex };\n}\nexport {\n  Virtualizer,\n  approxEqual,\n  debounce,\n  defaultKeyExtractor,\n  defaultRangeExtractor,\n  elementScroll,\n  measureElement,\n  memo,\n  notUndefined,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll\n};\n//# sourceMappingURL=index.js.map\n","import * as React from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { Virtualizer, elementScroll, observeElementOffset, observeElementRect, windowScroll, observeWindowOffset, observeWindowRect } from \"@tanstack/virtual-core\";\nexport * from \"@tanstack/virtual-core\";\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction useVirtualizerBase(options) {\n  const rerender = React.useReducer(() => ({}), {})[1];\n  const resolvedOptions = {\n    ...options,\n    onChange: (instance2, sync) => {\n      var _a;\n      if (sync) {\n        flushSync(rerender);\n      } else {\n        rerender();\n      }\n      (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n    }\n  };\n  const [instance] = React.useState(\n    () => new Virtualizer(resolvedOptions)\n  );\n  instance.setOptions(resolvedOptions);\n  useIsomorphicLayoutEffect(() => {\n    return instance._didMount();\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate();\n  });\n  return instance;\n}\nfunction useVirtualizer(options) {\n  return useVirtualizerBase({\n    observeElementRect,\n    observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options\n  });\n}\nfunction useWindowVirtualizer(options) {\n  return useVirtualizerBase({\n    getScrollElement: () => typeof document !== \"undefined\" ? window : null,\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    initialOffset: () => typeof document !== \"undefined\" ? window.scrollY : 0,\n    ...options\n  });\n}\nexport {\n  useVirtualizer,\n  useWindowVirtualizer\n};\n//# sourceMappingURL=index.js.map\n"],"names":["memo","getDeps","fn","opts","result","deps","initialDeps","memoizedFunction","_a","_b","_c","_d","depTime","key","debug","call","Date","now","newDeps","length","some","dep","index","resultTime","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","onChange","updateDeps","notUndefined","value","msg","Error","debounce","targetWindow","ms","timeoutId","args","clearTimeout","setTimeout","apply","this","getRect","element","offsetWidth","offsetHeight","width","height","defaultKeyExtractor","defaultRangeExtractor","range","start","startIndex","overscan","end","endIndex","count","arr","i","push","observeElementRect","instance","cb","scrollElement","handler","rect","ResizeObserver","observer","entries","run","entry","borderBoxSize","box","inlineSize","blockSize","options","useAnimationFrameWithResizeObserver","requestAnimationFrame","observe","unobserve","addEventListenerOptions","passive","supportsScrollend","window","observeElementOffset","offset","fallback","useScrollendEvent","isScrollingResetDelay","createHandler","isScrolling","horizontal","isRtl","endHandler","addEventListener","registerScrollendEvent","removeEventListener","measureElement","elementScroll","adjustments","behavior","toOffset","scrollTo","Virtualizer","constructor","unsubs","scrollToIndexTimeoutId","measurementsCache","itemSizeCache","Map","pendingMeasuredCacheIndexes","scrollRect","scrollOffset","scrollDirection","scrollAdjustments","elementsCache","_ro","get","forEach","_measureElement","target","disconnect","setOptions","opts2","Object","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","initialRect","scrollMargin","gap","indexAttribute","initialMeasurementsCache","lanes","enabled","notify","sync","maybeNotify","calculateRange","cleanup","filter","Boolean","d","_didMount","_willUpdate","getScrollElement","ownerDocument","defaultView","cached","_scrollToOffset","getScrollOffset","getSize","getFurthestMeasurement","measurements","furthestMeasurementsFound","furthestMeasurements","m","measurement","has","lane","previousFurthestMeasurement","set","size","Array","from","values","sort","a","b","getMeasurementOptions","getMeasurements","clear","item","slice","furthestMeasurement","measuredSize","estimateSize","outerSize","lastIndex","getOffset","findNearestBinarySearch","endPerLane","fill","pos","startPerLane","getVirtualIndexes","indexFromElement","node","attributeName","indexStr","getAttribute","parseInt","warn","prevNode","isConnected","resizeItem","delta","shouldAdjustScrollPositionOnItemSizeChange","delete","getVirtualItems","indexes","virtualItems","k","len","getVirtualItemForOffset","getOffsetForAlignment","align","itemSize","maxOffset","getTotalSize","getOffsetForIndex","isDynamicMode","cancelScrollToIndex","scrollToOffset","scrollToIndex","initialAlign","offsetAndAlign","latestOffset","currentScrollOffset","abs","scrollBy","endByLane","val","scrollToFn","measure","low","high","getCurrentValue","middle","currentValue","useIsomorphicLayoutEffect","document","React.useLayoutEffect","useLayoutEffect","React.useEffect","useEffect","useVirtualizer","rerender","React.useReducer","resolvedOptions","instance2","flushSync","React.useState","useState","useVirtualizerBase"],"mappings":"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","x_google_ignoreList":[0,1,2]}